# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .jl
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.14.1
#   kernelspec:
#     display_name: Julia 1.8.2
#     language: julia
#     name: julia-1.8
# ---

# Массив 4x3 со случайными целыми числами (от 1 до 20):
  a = rand(1:20,(4,3))

# Поэлементная сумма:
sum(a)

# Поэлементная сумма по столбцам:
sum(a,dims=1)

# Поэлементная сумма по строкам:
sum(a,dims=2)

# Поэлементное произведение:
prod(a)

# Поэлементное произведение по столбцам:
prod(a,dims=1)

# Поэлементное произведение по строкам:
prod(a,dims=2)

 # Подключение пакета Statistics:
import Pkg
Pkg.add("Statistics")
using Statistics

# Вычисление среднего значения массива:
mean(a)

# Среднее по столбцам:
mean(a,dims=1)

# Среднее по строкам:
mean(a,dims=2)

# Подключение пакета LinearAlgebra:
import Pkg
Pkg.add("LinearAlgebra")
using LinearAlgebra

# Массив 4x4 со случайными целыми числами (от 1 до 20):
b = rand(1:20,(4,4))

# Транспонирование:
transpose(b)

# След матрицы (сумма диагональных элементов):
tr(b)

# Извлечение диагональных элементов как массив:
diag(b)

# Ранг матрицы:
rank(b)

# Инверсия матрицы (определение обратной матрицы):
inv(b)

# Определитель матрицы:
det(b)

# Псевдобратная функция для прямоугольных матриц:
pinv(a)

# +
# Создание вектора X:
X = [2, 4, -5]

# Вычисление евклидовой нормы:
norm(X)
# -

# Вычисление p-нормы:
p=1
norm(X,p)

# Расстояние между двумя векторами X и Y:
X = [2, 4, -5];
Y = [1,-1,3];
norm(X-Y)

# Проверка по базовому определению:
sqrt(sum((X-Y).^2))

# Угол между двумя векторами:
acos((transpose(X)*Y)/(norm(X)*norm(Y)))

# Создание матрицы:
d = [5 -4 2 ; -1 2 3; -2 1 0]
# Вычисление Евклидовой нормы:
opnorm(d)

# Вычисление p-нормы:
p=1
opnorm(d,p)

# Поворот на 180 градусов:
rot180(d)

# Переворачивание строк:
reverse(d,dims=1)

# Переворачивание столбцов
reverse(d,dims=2)

# Матрица 2x3 со случайными целыми значениями от 1 до 10:
A = rand(1:10,(2,3))

# Матрица 3x4 со случайными целыми значениями от 1 до 10:
B = rand(1:10,(3,4))

# Произведение матриц A и B:
A*B

# Единичная матрица 3x3:
Matrix{Int}(I, 3, 3)

# Скалярное произведение векторов X и Y:
X = [2, 4, -5]
Y = [1,-1,3]
dot(X,Y)

# тоже скалярное произведение:
X'Y

# Задаём квадратную матрицу 3x3 со случайными значениями:
A = rand(3, 3)

# Задаём единичный вектор:
x = fill(1.0, 3)

# Задаём вектор b:
b = A*x

# Решение исходного уравнения получаем с помощью функции \
# (убеждаемся, что x - единичный вектор):
A\b

# LU-факторизация:
Alu = lu(A)

# Матрица перестановок:
Alu.P

# Вектор перестановок:
Alu.p

# Матрица L:
Alu.L

# Матрица U:
Alu.U

# Решение СЛАУ через матрицу A:
A\b

# Решение СЛАУ через объект факторизации:
Alu\b

# Детерминант матрицы A:
det(A)

# Детерминант матрицы A через объект факторизации:
det(Alu)

# QR-факторизация:
Aqr = qr(A)

# Матрица Q:
Aqr.Q

# Матрица R:
Aqr.R

# Проверка, что матрица Q - ортогональная:
Aqr.Q'*Aqr.Q

#  Симметризация матрицы A:
Asym = A + A'

# Спектральное разложение симметризованной матрицы:
AsymEig = eigen(Asym)

# Собственные значения:
AsymEig.values

#Собственные векторы:
AsymEig.vectors

# Проверяем, что получится единичная матрица:
inv(AsymEig)*Asym

# Матрица 1000 х 1000:
n = 1000
A = randn(n,n)

# Симметризация матрицы:
Asym = A + A'

# Проверка, является ли матрица симметричной:
issymmetric(Asym)

# Добавление шума:
Asym_noisy = copy(Asym)
Asym_noisy[1,2] += 5eps()

# Проверка, является ли матрица симметричной:
issymmetric(Asym_noisy)

# Явно указываем, что матрица является симметричной:
Asym_explicit = Symmetric(Asym_noisy)

import Pkg
Pkg.add("BenchmarkTools")
using BenchmarkTools

# Оценка эффективности выполнения операции по нахождению 
# собственных значений симметризованной матрицы:
@btime eigvals(Asym);

# Оценка эффективности выполнения операции по нахождению
# собственных значений зашумлённой матрицы:
@btime eigvals(Asym_noisy);

# Оценка эффективности выполнения операции по нахождению
# собственных значений зашумлённой матрицы,
# для которой явно указано, что она симметричная:
@btime eigvals(Asym_explicit);

# Трёхдиагональная матрица 1000000 х 1000000:
n = 1000000;
A = SymTridiagonal(randn(n), randn(n-1))

# + tags=[]
# Оценка эффективности выполнения операции по нахождению
# собственных значений:
@btime eigmax(A)
# -

B = Matrix(A)

# Матрица с рациональными элементами:
Arational = Matrix{Rational{BigInt}}(rand(1:10, 3, 3))/10

# Единичный вектор:
x = fill(1, 3)

# Задаём вектор b:
b = Arational*x

# Решение исходного уравнения получаем с помощью функции \ 
# (убеждаемся, что x - единичный вектор):
Arational\b

# LU-разложение:
lu(Arational)

# +
# ЗАДАНИЯ ДЛЯ САМОСТОЯТЕЛЬНОГО ВЫПОЛНЕНИЯ

# +
# 1.1

v = [1, 2, 3, 4, 5]
dot_v = v'v
# -

# 1.2
outer_v = v * v'

# +
#2.1

A = [ 1 1; 1 -1]
b = [2;3]
A\b
# -

A = [1 1; 2 2]
b = [4;2]
A\b

A = [1 1; 2 2]
b = [2;5]
A\b

A = [1 1; 2 2; 3 3]
b = [1; 2; 3]
A\b

A = [1 1; 2 1; 1 -1]
b = [2; 1; 3]
A\b

A = [1 1; 2 1; 3 2]
b = [2; 1; 3]
A\b

# +
# 2.2

A = [1 1 1; 1 -1 -2]
b = [2; 3]
A\b
# -

A = [1 1 1; 2 2 -3; 3 1 1]
b = [2; 4; 1]
A\b

A = [1 1 1; 1 1 2; 2 2 3]
b = [1; 0; 1]
A\b

A = [1 1 1; 1 1 2; 2 2 3]
b = [1; 0; 0]
A\b

# 3.1
M = [1 -2; -2 1]
Diagonal(eigen(M).values)

Matrix(Diagonal(eigen(M).values))

M = [1 -2; -2 3]
Diagonal(eigen(M).values)

M = [1 -2 0; -2 1 2; 0 2 0]
Diagonal(eigen(M).values)

# +
# 3.2

C = [1 -2; -2 1]
C^10
# -

C = [5 -2; -2 5]
sqrt(C)

C = [1 -2; -2 1]
C^(1//3)

C = [1 2; 2 3]
sqrt(C)

# +
#3.3

A = [140 97 74 168 131;
    97 106 89 131 36;
    74 89 152 144 71;
    168 131 144 54 142;
    131 36 71 142 36]
# -

Diagonal(eigen(M).values)

lu(A).L

@btime Diagonal(eigen(M).values);

@btime lu(A).L;

# +
# 4.1

A = [1 2; 3 4]
E = Matrix{Int}(I, 2, 2)
y = rand(0:10000, 2)
all(>=(0), y\(E-A))
# -

A = Matrix{Rational{Int}}([1 2; 3 4])/2
y = rand(0:10000, 2)
all(>=(0), y\(E-A))

A = Matrix{Rational{Int}}([1 2; 3 4])/10
y = rand(0:10000, 2)
all(>=(0), y\(E-A))

# +
# 4.2

A = [1 2; 3 1]
all(>=(0), inv(E-A))
# -

A = Matrix{Rational{Int}}([1 2; 3 1])/2
all(>=(0), inv(E-A))

A = Matrix{Rational{Int}}([1 2; 3 1])/10
all(>=(0), inv(E-A))

# 4.3
A = [1 2; 3 1]
all(<(1), broadcast(abs,eigvals(A)))

A = Matrix{Rational{Int}}([1 2; 3 1])/2
all(<(1), broadcast(abs,eigvals(A)))

A = Matrix{Rational{Int}}([1 2; 3 1])/10
all(<(1), broadcast(abs,eigvals(A)))

A = [0.1 0.2 0.3; 0 0.1 0.2; 0 0.1 0.3]
all(<(1), broadcast(abs,eigvals(A)))
